using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Linq;

// This script handles the generation of terrain, settings for it,
// and control of it from the inspector

// to do: design the generation algorithm on paper, including:
// tile generation types, level - depth relationship, correct ammounts of tiles per depth level, generation chances, multiple type 2 and 3 tiles, ...
// bruh
// to sie wkopałam w algorytmikę

// this is a mess I will fix it after showcase
// copium

public class TerrainGeneration : MonoBehaviour
{
    // fields that are relevant to config of generation
    [Header("Tilemap options")]
    [SerializeField] private Tilemap terrainTilemap;
    [SerializeField] BreakableTile rockTile, oreTile, plantTile, goldTile;

    [Header("Size of generated map")]
    [Range(0, 1000)][SerializeField] private int width = 10;
    [Range(0, 1000)][SerializeField] private int height = 10;

    [Header("Generation options")]
    [Tooltip("small - big chunks")][SerializeField] private float smoothness = 20f;
    [Range(0, 100)][Tooltip("small - more filled")][SerializeField] private int rockBorder = 40;
    [Range(0, 100)][Tooltip("small - more filled")][SerializeField] private int resourceBorder1 = 50;

    [Header("Enemies")]
    [SerializeField] private Transform enemiesParent;
    [SerializeField] private Object enemy1;
    [SerializeField] private Object enemy2;

    List<Object> enemies = new List<Object>();
    List<int> perlinValues = new List<int>();
    List<TileBase> tilesToSet = new List<TileBase>();

    float seed; // should not be visible or changeable

    private void Update()
    {
        // keys to quickly generate, clear terrain - for testing
        if (Input.GetKeyDown(KeyCode.I))
        {
            ButtonNewTerrain();
        }
        if (Input.GetKeyDown(KeyCode.O))
        {
            ButtonSameTerrain();
        }
        if (Input.GetKeyDown(KeyCode.P))
        {
            ButtonClearTerrain();
        }
    }

    private void OnDrawGizmos() {
        // displays a gizmo of the size and position of terrain that is/ will be generated
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(new Vector3(width/2, height/-2, 0), new Vector3(width, height, 0));
    }

    public void GetTerrainSize(out float _height, out float _width)
    {
        _height = height;
        _width = width;
    }
    
    public void GenerateTerrain()
    {
        PerlinToList();
        tilesToSet.Clear();

        // first iteration - blocks generated from Perin noise
        foreach (int value in perlinValues)
        {
            if (value > resourceBorder1)
            {
                tilesToSet.Add(oreTile);
            }
            else if (value > rockBorder)
            {
                tilesToSet.Add(rockTile);
            }
            else tilesToSet.Add(null);
        }

        // second iteration - generated by chance
        for (int i = width; i < tilesToSet.Count() - width; i++ )
        {
            // plants
            if (tilesToSet[i - width] == rockTile && 
                tilesToSet[i + width] == null && 
                Random.Range(0, 101) < plantTile.generationValue)
                {
                    tilesToSet[i] = plantTile;
                }

            // gems
            if ((tilesToSet[i] == rockTile || 
                tilesToSet[i] == oreTile) && 
                Random.Range(0, 101) < goldTile.generationValue)
                {
                    tilesToSet[i] = goldTile;
                }
        }

        //set the tiles
        BoundsInt _currentArea = new BoundsInt(0, (-1)*height, 0, width, height, 1);

        terrainTilemap.SetTilesBlock(_currentArea, tilesToSet.ToArray());

        SpawnEnemies();
    }

    void PerlinToList() {

        perlinValues.Clear();

        for (int xCoord = 0; xCoord < width; xCoord++)
        {
            for (int yCoord = 0; yCoord < height; yCoord++)
            {
                float x = (float)xCoord / width * smoothness + seed;
                float y = (float)yCoord / height * smoothness + seed;

                perlinValues.Add(Mathf.RoundToInt (Mathf.PerlinNoise(x, y) * 100));
            }
        }
    }

    private void SpawnEnemies()
    {
        BoundsInt _currentArea;
        TileBase[] _tileArray = new TileBase[9];
        int _counter = 0;

        for (int y = -3; y > height*-1; y-=3)
        {
            for (int x = 0; x < width-2; x+=3)
            {
                _currentArea = new BoundsInt(x, y, 0, 3, 3, 1);
                _tileArray = terrainTilemap.GetTilesBlock(_currentArea);

                if (_tileArray.All(x => x == null) && Random.Range(0, 101) <= 5)
                {
                    Object newEnemy = Instantiate(enemy1, new Vector3(_currentArea.center.x, _currentArea.center.y, 0), enemiesParent.rotation, enemiesParent);
                    enemies.Add(newEnemy);
                    _counter++;
                }
                else if (_tileArray.All(x => x == null) && Random.Range(0, 101) <= 5)
                {
                    Object newEnemy = Instantiate(enemy2, new Vector3(_currentArea.center.x, _currentArea.center.y, 0), enemiesParent.rotation, enemiesParent);
                    enemies.Add(newEnemy);
                    _counter++;
                }

            }
        }

        // Debug.Log("enemies spawned: " + _counter);
    }

    // functions that are called when buttons are pressed
    // both on keyboard (I, O, P) and in inspector
    public void ButtonClearTerrain()
    {
        terrainTilemap.ClearAllTiles();
        terrainTilemap.GetComponentInChildren<SpriteRenderer>().enabled = false;

        ClearEnemies();
        
    }

    private void ClearEnemies()
    {
        #if UNITY_EDITOR
            foreach (Object enemy in enemies)
            {
                GameObject.DestroyImmediate(enemy);
            }
        #else
            foreach (Object enemy in enemies)
            {
                GameObject.Destroy(enemy);
            }
        #endif
    }

    public void ButtonNewTerrain()
    {
        ButtonClearTerrain();
        seed = Random.Range(-1000000, 1000000);
        GenerateTerrain();
    }

    public void ButtonSameTerrain()
    {
        ButtonClearTerrain();
        GenerateTerrain();
    }
}
