using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Linq;

// This script handles the generation of terrain, settings for it,
// and control of it from the inspector

// to do: design the generation algorithm on paper, including:
// tile generation types, level - depth relationship, correct ammounts of tiles per depth level, generation chances, multiple type 2 and 3 tiles, ...
// bruh
// to sie wkopałam w algorytmikę

// this is a mess I will fix it after showcase
// copium

public class TerrainGeneration : MonoBehaviour
{
    // fields that are relevant to config of generation
    [Header("Tilemap options")]
    [SerializeField] private Tilemap terrainTilemap;
    [SerializeField] BreakableTile rockTile, oreTile, plantTile, goldTile;

    [Header("Size of generated map")]
    [Range(0, 1000)][SerializeField] private int width = 10;
    [Range(0, 1000)][SerializeField] private int height = 10;

    [Header("Generation options")]
    [Tooltip("small - big chunks")][SerializeField] private float smoothness = 20f;
    [Range(0, 100)][Tooltip("small - more filled")][SerializeField] private int rockBorder = 40;
    [Range(0, 100)][Tooltip("small - more filled")][SerializeField] private int resourceBorder1 = 50;

    [Header("Enemies")]
    [SerializeField] private Transform enemiesParent;
    [SerializeField] private Object enemy1;
    [SerializeField] private Object enemy2;
    
    // [Range(0, 100)][Tooltip("small - more filled")][SerializeField] private int resourceBorder2 = 60;
    // [Range(0, 100)][SerializeField] int plantChance = 50;

    float seed; // should not be visible or changeable

    /* private List<TileBase> type1Tiles = new();
    private List<BreakableTile> type2Tiles = new();
    private List<BreakableTile> type3Tiles = new(); */

    private void Update()
    {
        // keys to quickly generate, clear terrain - for testing
        if (Input.GetKeyDown(KeyCode.I))
        {
            ButtonNewTerrain();
        }
        if (Input.GetKeyDown(KeyCode.O))
        {
            ButtonSameTerrain();
        }
        if (Input.GetKeyDown(KeyCode.P))
        {
            ButtonClearTerrain();
        }
    }

    private void OnDrawGizmos() {
        // displays a gizmo of the size and position of terrain that is/ will be generated
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(new Vector3(width/2, height/-2, 0), new Vector3(width, height, 0));
    }

    public void GetTerrainSize(out float _height, out float _width)
    {
        _height = height;
        _width = width;
    }
    
    public void GenerateTerrain()
    {
        // first iteration - blocks generated from Perin noise
        for (int x = 0; x < width; x++)
        {
            for (int y = height*-1; y < 0; y++)
            {
                // calls the perlin noise function, and if output is larger than some threshold,
                // fills in the corresponding tile
                int _perlinOutput = Perlin(x,y);

                /* if (_perlinOutput > resourceBorder2 && type1Tiles[2] != null)
                {
                    terrainTilemap.SetTile(new Vector3Int(x, y, 0), type1Tiles[2]);
                }
                else */  
                
                if (_perlinOutput > resourceBorder1)
                {
                    terrainTilemap.SetTile(new Vector3Int(x, y, 0), oreTile);
                }
                else if (_perlinOutput > rockBorder)
                {
                    terrainTilemap.SetTile(new Vector3Int(x, y, 0), rockTile);
                }
            }
        }

        // second iteration - generated by chance
        for (int x = 0; x < width; x++)
        {
            for (int y = height*-1; y < 0; y++)
            {
                // plants
                if (terrainTilemap.GetTile(new Vector3Int(x, y-1, 0)) == rockTile && 
                    terrainTilemap.GetTile(new Vector3Int(x, y+1, 0)) == null && 
                    Random.Range(0, 101) < plantTile.generationValue)
                {
                    terrainTilemap.SetTile(new Vector3Int(x, y, 0), plantTile);
                }

                // gems
                if ((terrainTilemap.GetTile(new Vector3Int(x, y, 0)) == rockTile || 
                    terrainTilemap.GetTile(new Vector3Int(x, y, 0)) == oreTile) &&
                    Random.Range(0, 101) < goldTile.generationValue)
                {
                    terrainTilemap.SetTile(new Vector3Int(x, y, 0), goldTile);
                }
                

            }
        }

        BoundsInt _currentArea;
        TileBase[] _tileArray = new TileBase[9];
        int _counter = 0;

        // enemies
        for (int y = -3; y > height*-1; y-=3)
        {
            for (int x = 0; x < width-2; x+=3)
            {
                _currentArea = new BoundsInt(x, y, 0, 3, 3, 1);
                _tileArray = terrainTilemap.GetTilesBlock(_currentArea);

                if (_tileArray.All(x => x == null) && Random.Range(0, 101) <= 5)
                {
                    Instantiate(enemy1, new Vector3(_currentArea.center.x, _currentArea.center.y, 0), enemiesParent.rotation, enemiesParent);
                    _counter++;
                }
                else if (_tileArray.All(x => x == null) && Random.Range(0, 101) <= 5)
                {
                    Instantiate(enemy2, new Vector3(_currentArea.center.x, _currentArea.center.y, 0), enemiesParent.rotation, enemiesParent);
                    _counter++;
                }

            }
        }

        Debug.Log("enemies spawned: " + _counter);
    }
    

    // function that calculates an output from Perlin noise 
    int Perlin(int xCoord, int yCoord) {
        
        float x = (float)xCoord / width * smoothness + seed;
        float y = (float)yCoord / height * smoothness + seed;

        int result = Mathf.RoundToInt (Mathf.PerlinNoise(x, y) * 100);
        return result;
    }

    // functions that are called when buttons are pressed
    // both on keyboard (I, O, P) and in inspector
    public void ButtonClearTerrain()
    {
        terrainTilemap.ClearAllTiles();
        terrainTilemap.GetComponentInChildren<SpriteRenderer>().enabled = false;


        foreach (Transform child in enemiesParent)
        {
            # if UNITY_EDITOR
            GameObject.DestroyImmediate(child.gameObject);
            # else
            GameObject.Destroy(child.gameObject);
            #endif
        }
    }

    public void ButtonNewTerrain()
    {
        ButtonClearTerrain();
        seed = Random.Range(-1000000, 1000000);
        GenerateTerrain();
    }

    public void ButtonSameTerrain()
    {
        ButtonClearTerrain();
        GenerateTerrain();
    }
}

        /*  ================ code to fix later!!!! in Start()



        // load the SO that contains info about blocks
        BlockTableScriptableObject tempTileTable = Resources.Load("TerrainBlocksTable") as BlockTableScriptableObject;

        // populate the tables
        foreach (BlockScriptableObject block in tempTileTable.blockTable)
        {
            switch (block.tile.generationMethod)
            {
                case 1:
                    type1Tiles.Add(block.tile);
                    Debug.Log("type 1 " + block.tile.name);
                    break;

                case 2:
                    type2Tiles.Add(block.tile);
                    Debug.Log("type 2 " + block.tile.name);

                    break;

                case 3:
                    type3Tiles.Add(block.tile);
                    Debug.Log("type 3 " + block.tile.name);

                    break;

                default:
                    Debug.Log("tile does not have generation method: " + block.tile.name);
                    break;
            }
        } 
        
        // unload when not needed
        Resources.UnloadAsset(tempTileTable);


        // make this better when I figure out depth levels
        if (type1Tiles.Count > 3)
        {
            Debug.LogWarning("too many resource blocks");
        }
         */